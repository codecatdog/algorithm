/**
 * 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字
 * 要求时间复杂度是O(n)，空间复杂度是O(1)。
 * 
 * 示例 1：
 * 
 * 输入：nums = [4,1,4,6]
 * 输出：[1,6] 或 [6,1]
 * 
 * 思路：
 * 1. 简化问题，若一个数组中只有一个数字出现一次，
 *    则通过将数组所有元素经过异或操作便能得到那个唯一的数( 1 ^ 1 ^ 6 = 6)
 * 
 * 2. 若能将数组划分为两个子数组，且每个子数组正好包含一个唯一的数，便可求解此题；
 * 
 * 3. 通过异或所有数组元素，最终得到的结果是出现一次的两个数字的异或结果 
 *    ( 示例1：z = 1 ^ 6 -> 0001 ^ 0110 = 0111, 结果位为1代表两个数对应的二进制位不同)
 * 
 * 4. 利用结果位为1代表两个数对应的二进制位不同这一点，将数组划分为两个子数组；
 *    则两个数必定分别在两个子数组中
 *    划分数组： 设m = 1 = 0001，与结果按位相与，找到第一位出现1的位置
 *    (m & z == 1时，则m与1， 6相与时结果必定不同； 若m & z != 1时，将m左移，进行下一位的判定)
 * 
 * 5. 分别对子数组进行异或
 * 
 */

/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumbers = function(nums) {
    let len = nums.length;
    let z = 0; // 记录数组中唯二数字的异或结果
    for(let i = 0; i < len; i ++) {
        z ^= nums[i];
    }
    let m = 1; // 记录两个数必不同的二进制位
    while((m & z) === 0) {
        m <<= 1;
    }

    let ans1 = 0, ans2 = 0; // 任何数与0异或还是原数
    for(let i = 0; i < len; i ++) {
        if(m & nums[i]) {  // 根据与m的与结果划分数组 并进行异或操作 得到出现一次的唯一数字
            ans1 ^= nums[i]
        } else {
            ans2 ^= nums[i]
        }
        
    }
    return [ans1, ans2];
};

console.log(singleNumbers([1,2,10,4,1,4,3,3]))